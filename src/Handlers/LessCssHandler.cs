using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Web;
using System.IO;
using DotSmart.Properties;
using System.Text.RegularExpressions;
using System.Diagnostics;

namespace DotSmart
{
    public class LessCssHandler : ScriptHandlerBase, IHttpHandler
    {
        static string _lessJs;
        static string _lessWsf;

        /// <summary>
        /// Initializes a new instance of the LessCssHandler class.
        /// </summary>
        static LessCssHandler()
        {
            _lessWsf = Path.Combine(TempDirectory, "less.wsf");
            _lessJs = Path.Combine(TempDirectory, "less.js");

            ExportResourceIfNewer(_lessWsf, Resources.LessWsf);
            ExportResourceIfNewer(_lessJs, Resources.LessJs);
        }

        public void ProcessRequest(HttpContext context)
        {
            context.Response.ContentType = "text/css";

            context.Response.Write("/* Generated by DotSmart LessCoffee on " + DateTime.Now + " - http://dotsmart.net */ \r\n");
            context.Response.Write("/* Using LESS - Leaner CSS v1.2.0 - http://lesscss.org - Copyright (c) 2009-2011, Alexis Sellier */ \r\n\r\n");

            string lessFile = context.Server.MapPath(context.Request.FilePath);

            bool success = renderStylesheet(lessFile, context.Response.Output);
            if (success)
            {
                // look for "@import" and add those to dependencies also
                var lessFiles = parseImports(lessFile).Concat(new[] { lessFile }).ToArray();
                SetCacheability(context.Response, lessFiles);
            }
        }

        static IEnumerable<string> parseImports(string lessFileName)
        {
            /* These are equivalent:
             * 
             *   @import "lib.less";
             *   @import "lib";
             * 
             * Ignore css though as they are not imported by LESS
             */
            string dir = Path.GetDirectoryName(lessFileName);

            var importRegex = new Regex(@"@import\s+[""'](.*)[""'];");

            return (from line in File.ReadAllLines(lessFileName)
                    let match = importRegex.Match(line)
                    let file = match.Groups[1].Value
                    where match.Success
                      && !file.EndsWith(".css", StringComparison.OrdinalIgnoreCase)
                    select Path.Combine(dir, Path.ChangeExtension(file, ".less"))
            );
        }

        bool renderStylesheet(string lessFilePath, TextWriter output)
        {
            try
            {
                RenderCss(lessFilePath, output, compress: !DebugMode);
                return true;
            }
            catch (Exception ex)
            {
                output.WriteLine("/* " + ex.Message + " */");
                return false;
            }
        }

        public static void RenderCss(string lessFilePath, TextWriter output, bool compress = true, string lessPrologue = null)
        {
            TextReader lessFile;
            if (lessPrologue != null)
                lessFile = new StringReader(lessPrologue + File.ReadAllText(lessFilePath));
            else
                lessFile = new StreamReader(lessFilePath);

            using (lessFile)
            using (var stdErr = new StringWriter())
            {
                // So that relative @import paths resolve
                int exitCode = executeJs(_lessWsf, "- " + (compress ? "-compress" : ""), lessFile, output, stdErr, Path.GetDirectoryName(lessFilePath));
                if (exitCode != 0)
                    throw new ApplicationException("Error " + exitCode + " in '" + lessFilePath + "': " + stdErr.ToString().Trim());
            }
        }

        static int executeJs(string scriptPath, string args, TextReader stdin, TextWriter stdout, StringWriter stderr, string workingDirectory)
        {
            int exitCode = ProcessUtil.Exec("cscript.exe", "//nologo \"" + scriptPath + "\" " + args, stdin, stdout, stderr, workingDirectory: workingDirectory);
            return exitCode;
        }

        public bool IsReusable
        {
            get { return false; }
        }

    }
}
